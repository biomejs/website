---
title: Архітектура
description: Як працює Biome під капотом.
---

Цей документ охоплює деякі внутрішні механізми Biome та те, як вони використовуються в проекті.

## Парсер і CST

Архітектура парсера базується на внутрішній форк [rowan], бібліотеки, яка реалізує патерн [Green and Red tree].

CST (Concrete Syntax Tree) - це структура даних, дуже схожа на AST (Abstract Syntax Tree), яка зберігає всю інформацію про програму, включаючи тривіальні елементи.

**Тривіальні елементи** представлені всією інформацією, яка важлива для виконання програми:
- пробіли
- табуляції
- коментарі

Тривіальні елементи прикріплюються до вузла. Вузол може мати провідні та наступні тривіальні елементи. Якщо читати код зліва направо, провідні тривіальні елементи з'являються перед ключовим словом, а наступні тривіальні елементи з'являються після ключового слова.

Провідні та наступні тривіальні елементи класифікуються наступним чином:
- Всі тривіальні елементи до токена/ключового слова (включаючи розриви рядків) будуть **провідними тривіальними елементами**;
- Все до наступного розриву рядка (але не включаючи його) буде **наступними тривіальними елементами**;

У наведеному нижче прикладі JavaScript, `// comment 1` є наступним тривіальним елементом токена `;`, а `// comment 2` є провідним тривіальним елементом ключового слова `const`. Нижче наведено мінімізовану версію CST, представлену Biome:

```js
const a = "foo"; // comment 1
// comment 2
const b = "bar";
```

```
0: JS_MODULE@0..55
  ...
    1: SEMICOLON@15..27 ";" [] [Whitespace(" "), Comments("// comment 1")]
  1: JS_VARIABLE_STATEMENT@27..55
    ...
    1: CONST_KW@27..45 "const" [Newline("\n"), Comments("// comment 2"), Newline("\n")] [Whitespace(" ")]
  3: EOF@55..55 "" [] []
```

CST ніколи не доступний безпосередньо за задумом; розробник може читати його інформацію, використовуючи Red tree, за допомогою ряду API, які автоматично генеруються з граматики мови.

#### Стійкий і відновлюваний парсер

Для створення CST парсер повинен бути стійким до помилок і відновлюваним:
- стійкий: парсер, який здатний продовжувати парсинг після виявлення синтаксичних помилок, що належать до мови;
- відновлюваний: парсер, який здатний **зрозуміти**, де сталася помилка, і продовжити парсинг, створюючи **правильну** інформацію;

Відновлювана частина парсера не є наукою, і жодні правила не є непорушними. Це означає, що залежно від того, що парсер парсив і де сталася помилка, парсер може відновитися очікуваним чином.

Парсер також використовує 'Bogus' вузли для захисту споживачів від споживання некоректного синтаксису. Ці вузли використовуються для позначення зламаного коду, спричиненого синтаксичною помилкою.

У наступному прикладі дужки в `while` відсутні, хоча парсер може відновитися належним чином і представити код з пристойним CST. Дужки та умова циклу позначені як відсутні, а блок коду правильно розпарсений:

```js
while {}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
  JsWhileStatement {
    while_token: WHILE_KW@0..6 "while" [] [Whitespace(" ")],
    l_paren_token: missing (required),
    test: missing (required),
    r_paren_token: missing (required),
    body: JsBlockStatement {
    l_curly_token: L_CURLY@6..7 "{" [] [],
    statements: JsStatementList [],
    r_curly_token: R_CURLY@7..8 "}" [] [],
    },
  },
  ],
  eof_token: EOF@8..8 "" [] [],
}
```

Це помилка, яка виникає під час парсингу:

```
main.tsx:1:7 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ очікувався `(`, але натомість знайдено `{`

  > 1 │ while {}
    │       ^

  ℹ Видаліть {
```

Те ж саме не можна сказати про наступний фрагмент. Парсер не може правильно зрозуміти синтаксис під час фази відновлення, тому йому потрібно покладатися на bogus вузли, щоб позначити деякий синтаксис як помилковий. Зверніть увагу на `JsBogusStatement`:

```js
function}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
  TsDeclareFunctionDeclaration {
    async_token: missing (optional),
    function_token: FUNCTION_KW@0..8 "function" [] [],
    id: missing (required),
    type_parameters: missing (optional),
    parameters: missing (required),
    return_type_annotation: missing (optional),
    semicolon_token: missing (optional),
  },
  JsBogusStatement {
    items: [
    R_CURLY@8..9 "}" [] [],
    ],
  },
  ],
  eof_token: EOF@9..9 "" [] [],
}
```

Це помилка, яку ми отримуємо під час фази парсингу:

```
main.tsx:1:9 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ очікувалося ім'я для функції в оголошенні функції, але його не знайдено

  > 1 │ function}
    │         ^
```

## Форматувач (WIP)

## Лінтер (WIP)

## Даймон (WIP)

Biome використовує архітектуру сервер-клієнт для виконання своїх завдань.

[даймон] - це довготривалий сервер, який Biome запускає у фоновому режимі та використовує для обробки запитів від редактора та CLI.

[rowan]: https://github.com/rust-analyzer/rowan
[Green and Red tree]: https://learn.microsoft.com/en-us/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees
[даймон]: https://uk.wikipedia.org/wiki/Демон_(обчислювальна_техніка)
