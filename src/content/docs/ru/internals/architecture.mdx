---
title: Архитектура
description: Как работает Biome под капотом.
---

В этом документе рассматриваются некоторые внутренние механизмы Biome и их использование в проекте.

## Сканер

Biome имеет сканер, который отвечает за обход файловой системы для извлечения
важных метаданных о проектах. В частности, существует три способа использования
сканера:

- Для обнаружения вложенных файлов `biome.json`/`biome.jsonc` в монорепозиториях.
- Для обнаружения вложенных файлов `.gitignore`, если включена настройка [`vcs.useIgnoreFile`](/ru/reference/configuration/#vcsuseignorefile).
- Для индексации манифестов `package.json`, а также исходных файлов в проекте, если включены
  какие-либо правила из [проектной области](/ru/linter/domains/#project).

### Таргетирование сканера

Если правила проекта не включены, сканер автоматически нацеливается только на те
папки, которые актуальны для данной сессии.

Это означает, что если у вас большой монорепозиторий, и вы запускаете `biome check` из
папки `packages/foo/`, эта папка будет "целевой". Это означает,
что следующие папки будут просканированы на наличие вложенных файлов конфигурации и/или вложенных файлов игнорирования:

- Корневая папка репозитория.
- Папка `packages/`.
- Папка `packages/foo/`.
- Любые папки, существующие в `packages/foo/`, кроме `node_modules/` или
  тех, которые исключены вашей конфигурацией (см.
  [ниже](#configuring-the-scanner)).

Другие папки, которые могут быть смежными с `packages/` или `packages/foo/`, будут
автоматически пропущены.

Аналогично, если вы запустите `biome format packages/bar/src/index.ts` из корня
репозитория, сканер нацелится на папку `packages/bar/src/`.

Если включены правила проекта, эти оптимизации не применяются.

### Настройка сканера

Сканер можно настроить с помощью
параметра [`files.includes`](/ru/reference/configuration/#interactionwiththescanner).

## Парсер и CST

Архитектура парсера основана на внутреннем форке [rowan], библиотеки,
которая реализует паттерн [Green and Red tree].

CST (Concrete Syntax Tree) - это структура данных, очень похожая на AST (Abstract Syntax Tree), которая отслеживает всю информацию программы, включая тривии.

**Trivia** представлена всей той информацией, которая важна для работы программы:
- пробелы
- табуляции
- комментарии

Trivia прикреплена к узлу. Узел может иметь ведущую trivia и замыкающую trivia. Если вы читаете код слева направо, ведущая trivia появляется перед ключевым словом, а замыкающая trivia появляется после ключевого слова.

Ведущая trivia и замыкающая trivia классифицируются следующим образом:
- Вся trivia до токена/ключевого слова (включая переносы строк) будет **ведущей trivia**;
- Все до следующего переноса строки (но не включая его) будет **замыкающей trivia**;

Учитывая следующий фрагмент JavaScript, `// comment 1` является замыкающей trivia токена `;`, а `// comment 2` является ведущей trivia для ключевого слова `const`. Ниже приведена минимизированная версия CST, представленная Biome:

```js
const a = "foo"; // comment 1
// comment 2
const b = "bar";
```

```
0: JS_MODULE@0..55
    ...
      1: SEMICOLON@15..27 ";" [] [Whitespace(" "), Comments("// comment 1")]
    1: JS_VARIABLE_STATEMENT@27..55
        ...
        1: CONST_KW@27..45 "const" [Newline("\n"), Comments("// comment 2"), Newline("\n")] [Whitespace(" ")]
  3: EOF@55..55 "" [] []
```

CST никогда не доступен напрямую по дизайну; разработчик может читать его информацию с помощью Red tree, используя ряд API, которые автогенерируются из грамматики языка.


#### Устойчивый и восстанавливаемый парсер

Для построения CST парсеру необходимо быть устойчивым к ошибкам и восстанавливаемым:
- устойчивый: парсер, который способен возобновить парсинг после обнаружения синтаксических ошибок, принадлежащих языку;
- восстанавливаемый: парсер, который способен **понять**, где произошла ошибка, и быть способным возобновить парсинг, создавая **корректную** информацию;

Восстанавливаемая часть парсера - это не наука, и нет установленных правил. Это означает, что в зависимости от того, что парсер парсил и где произошла ошибка, парсер может восстановиться ожидаемым образом.

Парсер также использует узлы 'Bogus' для защиты потребителей от использования некорректного синтаксиса. Эти узлы используются для декорирования сломанного кода, вызванного синтаксической ошибкой.

В следующем примере скобки в `while` отсутствуют, хотя парсер может восстановиться хорошим образом и может представить код достойным CST. Скобки и условие цикла помечены как отсутствующие, а блок кода корректно распарсен:


```js
while {}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
    JsWhileStatement {
      while_token: WHILE_KW@0..6 "while" [] [Whitespace(" ")],
      l_paren_token: missing (required),
      test: missing (required),
      r_paren_token: missing (required),
      body: JsBlockStatement {
        l_curly_token: L_CURLY@6..7 "{" [] [],
        statements: JsStatementList [],
        r_curly_token: R_CURLY@7..8 "}" [] [],
      },
    },
  ],
  eof_token: EOF@8..8 "" [] [],
}
```

Это ошибка, выданная во время парсинга:

```
main.tsx:1:7 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ expected `(` but instead found `{`

  > 1 │ while {}
      │       ^

  ℹ Remove {
```

То же самое нельзя сказать о следующем фрагменте. Парсер не может должным образом понять синтаксис во время фазы восстановления, поэтому ему нужно полагаться на узлы bogus, чтобы пометить некоторый синтаксис как ошибочный. Обратите внимание на `JsBogusStatement`:

```js
function}
```

```
JsModule {
  interpreter_token: missing (optional),
  directives: JsDirectiveList [],
  items: JsModuleItemList [
    TsDeclareFunctionDeclaration {
      async_token: missing (optional),
      function_token: FUNCTION_KW@0..8 "function" [] [],
      id: missing (required),
      type_parameters: missing (optional),
      parameters: missing (required),
      return_type_annotation: missing (optional),
      semicolon_token: missing (optional),
    },
    JsBogusStatement {
      items: [
        R_CURLY@8..9 "}" [] [],
      ],
    },
  ],
  eof_token: EOF@9..9 "" [] [],
}
```

Это ошибка, которую мы получаем от фазы парсинга:

```
main.tsx:1:9 parse ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  ✖ expected a name for the function in a function declaration, but found none

  > 1 │ function}
      │         ^
```

## Форматтер

:::note
В разработке
:::

## Линтер

:::note
В разработке
:::
## Демон

:::note
В разработке
:::

Biome использует серверно-клиентскую архитектуру для выполнения своих задач.

[Демон][daemon] - это долгоживущий сервер,
который Biome порождает в фоновом режиме и использует для обработки запросов от редактора и CLI.


[rowan]: https://github.com/rust-analyzer/rowan
[Green and Red tree]: https://learn.microsoft.com/en-us/archive/blogs/ericlippert/persistence-facades-and-roslyns-red-green-trees
[daemon]: https://en.wikipedia.org/wiki/Daemon_(computing)
