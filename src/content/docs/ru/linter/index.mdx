---
title: Линтер
description: Как использовать линтер Biome.
---

import NumberOfRules from "@/components/generated/linter/NumberOfRules.astro";
import PackageManagerBiomeCommand from "@/components/PackageManagerBiomeCommand.astro";
import { Steps } from '@astrojs/starlight/components';
import EditorAction from "@/components/EditorAction.astro";

Линтер Biome статически анализирует ваш код для обнаружения и исправления распространенных ошибок и помогает писать более качественный, современный код.
Он [поддерживает несколько языков](/internals/language-support) и предоставляет в общей сложности **<NumberOfRules/> правил**.

Вы можете быстро попробовать линтер Biome через CLI. Следующая команда запускает линтер на всех файлах из корня вашего проекта:

<PackageManagerBiomeCommand command="lint" />

Или вы можете указать одну или несколько папок, например `./src` и `./public`

<PackageManagerBiomeCommand command="lint ./src ./public" />

Команда принимает список файлов и директорий.

:::caution
Если вы передаете glob как параметр, ваша оболочка развернет его. **Biome не поддерживает globs**.
Результат разворачивания зависит от вашей оболочки.
Например, некоторые оболочки не поддерживают рекурсивный glob `**` или альтернацию `{}` в следующей команде:

```shell
biome lint ./src/**/*.test.{js,ts}
```

Разворачивание оболочки имеет издержки производительности и ограничение на количество файлов, которые вы можете передать команде.

Использование globs **не рекомендуется**, вместо этого используйте конфигурацию `includes`.
:::

Для получения дополнительной информации обо всех доступных опциях обратитесь к [справочнику CLI](/reference/cli#biome-lint).


## Правила

Линтер организован в правила. Правило предназначено для применения или запрета стиля кода, использования чего-либо, что может привести к ошибке, и т.д. В целом, правило не должно конфликтовать с другим правилом, если не указано иное.
Правила Biome имеют конвенцию именования: правила, начинающиеся с `use*`, предназначены для применения/предложения чего-либо, в то время как правила, начинающиеся с `no*`, предназначены для запрета чего-либо. Когда правило обнаруживает *нарушение* своей концепции, оно выдает диагностику.

Например, [noDebugger](/linter/rules/no-debugger) запрещает использование операторов `debugger` в JavaScript-коде и выдает диагностику, когда находит таковой.

Линтер Biome поставляется с набором рекомендованных правил, которые варьируются в зависимости от языка, и включены по умолчанию при использовании конфигурации Biome по умолчанию (или без конфигурации) при запуске команды `lint` или `check`:

```shell
biome lint
biome check
```

Каждое правило линтера поставляется с [серьезностью](/reference/diagnostics#diagnostic-severity) по умолчанию, о которой вы можете узнать больше, прочитав документацию правила.

Правила разделены на [группы](#linter-groups). Например, правило `noDebugger` является частью группы [`suspicious`](#suspicious).

Biome поддерживает *языково-агностичные правила*. Это правила, которые работают для более чем одного языка, например, `noUselessEscapeInString`, которое может обнаруживать бесполезные escape-последовательности как в JavaScript, так и в CSS.

В отличие от других линтеров, Biome не предоставляет правил, которые проверяют форматирование кода; [форматировщик Biome](/formatter/) предназначен для обработки всех решений по форматированию.

Многие правила предоставляют **исправление кода**, которое может быть применено автоматически.

Biome различает [**безопасные исправления**](#safe-fixes) и [**небезопасные исправления**](#unsafe-fixes), которые работают немного по-разному: основное различие в том, что безопасные исправления могут автоматически применяться при сохранении файла, в то время как небезопасные исправления не могут. Однако пользователи могут переопределить, какие исправления считаются безопасными.

Линтер Biome поставляется с набором рекомендованных правил, которые автоматически включены и варьируются в зависимости от языка.

### Безопасные исправления

Безопасные исправления гарантированно не изменяют семантику вашего кода.
Они могут быть применены без явного просмотра.

Чтобы применить _безопасные исправления_ из CLI, используйте `--write`:

<PackageManagerBiomeCommand command="lint --write ./src" />

Из редактора, совместимого с LSP, вы можете применять безопасные исправления **при сохранении** с помощью code action `source.fixAll.biome`.
Обратитесь к документации вашего расширения, чтобы узнать, как его применить.

### Небезопасные исправления

Небезопасные исправления могут изменить семантику вашей программы.
Поэтому рекомендуется вручную просматривать изменения.

Чтобы применить как _безопасные исправления_, так и _небезопасные исправления_ из CLI, используйте `--write --unsafe`:

<PackageManagerBiomeCommand command="lint --write --unsafe ./src" />

Из редактора, совместимого с LSP, невозможно применить все небезопасные исправления при сохранении. Было бы нежелательно изменять семантику вашего кода при сохранении. Однако вы можете просмотреть отдельное исправление кода и выбрать его применение.

### Принципы правил

В Biome правила должны быть информативными и объяснять пользователю, почему правило срабатывает, и сообщать им, что им следует сделать для исправления ошибки.
Правило должно следовать этим **принципам**:

1. Объяснить пользователю ошибку. Обычно это сообщение диагностики.
2. Объяснить пользователю **почему** ошибка срабатывает. Обычно это реализовано с помощью дополнительной заметки.
3. Сказать пользователю, что ему следует сделать. Обычно это реализовано с помощью code action.
Если code action неприменим, заметка должна сообщить пользователю, что им следует сделать для исправления ошибки.

Если вы считаете, что правило не следует этим принципам, пожалуйста, [откройте issue](https://github.com/biomejs/biome/issues/new?assignees=&labels=S-To+triage&projects=&template=01_bug.yml&title=%F0%9F%90%9B+%3CTITLE%3E).

## Настройка линтера

Во многих случаях вы захотите изменить линтер в соответствии с вашими личными потребностями или потребностями вашей организации/проекта.
Biome позволяет настраивать линтер, и в этом разделе вы узнаете, как это сделать.


### Отключение правила

Вы можете отключить правило с помощью `off`.

Следующая конфигурация отключает рекомендованное правило `noDebugger`:

```json title="biome.json" ins="\"off\""
{
  "linter": {
    "rules": {
      "suspicious": {
        "noDebugger": "off"
      }
    }
  }
}
```

### Отключение рекомендованных правил

Вы можете отключить рекомендованные правила с помощью простой конфигурации. Это может быть полезно в случаях, когда вы хотите включить только несколько правил.

```json name="biome.json" ins={4}
{
  "linter": {
    "rules": {
      "recommended": false
    }
  }
}
```

### Изменение серьезности правила

Правила линтера Biome поставляются со своей собственной серьезностью по умолчанию. Если вы хотите применить серьезность по умолчанию, вы можете использовать конфигурацию `"on"`.

Например, `noShoutyConstants` не рекомендовано по умолчанию, и при срабатывании выдает диагностику с информационной серьезностью.

Если вы довольны этим значением по умолчанию и хотите его использовать, конфигурация будет выглядеть так:

```json title="biome.json" ins="\"on\""
{
  "linter": {
    "rules": {
      "style": {
        "noShoutyConstants": "on"
      }
    }
  }
}
```

Если вы не довольны серьезностью по умолчанию, Biome позволяет изменить ее на `"error"`, `"warn"` и `"info"`.

Диагностики с [`"error"`](/reference/diagnostics#error) всегда приводят к тому, что CLI завершается с кодом ошибки. Эта серьезность может быть полезна, когда вы хотите заблокировать CI, если есть нарушение, принадлежащее определенному правилу.

[Предупреждения](/reference/diagnostics#warning) похожи на ошибки, но они не приводят к тому, что CLI завершается с кодом ошибки, если не используется флаг `--error-on-warnings`. Возможным использованием серьезности `warn` является случай, когда вы хотите, чтобы CI проходил, пока все еще есть диагностики для данного правила.

Серьезность [`info`](/reference/diagnostics#information) не повлияет на код статуса выхода CLI, даже если передан `--error-on-warnings`.

### Изменение серьезности группы

Дополнительно вы можете контролировать серьезность правил линтера **на уровне группы**. Таким образом, можно контролировать серьезность диагностики **всех правил**, принадлежащих группе.

Например, проект не требует использования правил `a11y`, потому что это код, который выполняется на бэкенде, поэтому доступность не является проблемой. Следующий пример отключает все правила, принадлежащие группе `a11y`:

```json name="biome.json" ins={4}
{
  "linter": {
    "rules": {
      "a11y": "off"
    }
  }
}
```

### Настройка исправления кода

Как объяснено выше, правила могут выдавать исправления кода, которые являются **безопасными** или **небезопасными**. Biome позволяет настроить безопасное исправление, чтобы оно рассматривалось как небезопасное, и наоборот. Вы также можете полностью отключить исправление кода.

Исправления кода можно настроить с помощью опции `fix`. Она может иметь одно из трех значений:

- `none`: правило не будет выдавать исправление кода;
- `safe`: правило будет выдавать [безопасное исправление](#safe-fixes);
- `unsafe`: правило будет выдавать [небезопасное исправление](#unsafe-fixes);

```json title="biome.jsonc" ins={7,13,17}
{
  "linter": {
    "rules": {
      "correctness": {
        "noUnusedVariables": {
          "level": "error",
          "fix": "none" // не предлагается исправление кода для noUnusedVariables
        }
      },
      "style": {
        "useConst": {
          "level": "warn",
          "fix": "unsafe" // исправление кода для `useConst` теперь считается небезопасным
        },
        "useTemplate": {
          "level": "warn",
          "fix": "safe" // исправление кода для `useTemplate` теперь считается безопасным
        }
      }
    }
  }
}
```

### Пропуск правила или группы

Команда `biome lint` принимает опцию `--skip`, которая позволяет отключать отдельные правила или группы правил.

Например, следующая команда пропускает все правила, принадлежащие группе `style`, и правило `suspicious/noExplicitAny`:

```shell
biome lint --skip=style --skip=suspicious/noExplicitAny
```

### Запуск только правила или группы

Команда `biome lint` принимает опцию `--only`, которая позволяет запускать отдельные правила или группы правил.

Например, следующая команда запускает только правило `style/useNamingConvention`, правило `style/noInferrableTypes` и правила, принадлежащие `a11y`. Если правило отключено в конфигурации, то его уровень серьезности устанавливается на `error` для рекомендованного правила или `warn` в противном случае.

```shell
biome lint --only=style/useNamingConvention --only=style/noInferrableTypes --only=a11y
```

### Опции правил

Некоторые правила имеют опции.
Вы можете установить их, изменив значение правила.

- `level` будет указывать серьезность диагностики;
- `options` будут меняться в зависимости от правила.

```json title="biome.json"
{
  "linter": {
    "rules": {
      "style": {
        "useNamingConvention": {
          "level": "error",
          "options": {
            "strictCase": false
          }
        }
      }
    }
  }
}
```

### Домены

Домены — это функция Biome, которая позволяет группировать правила по технологии или, ну, _домену_. Примерами доменов являются `"react"`, `"solid"` и `"test"`.

Домен:
- имеет собственный набор рекомендованных правил;
- может быть автоматически включен, когда Biome обнаруживает определенные зависимости в вашем файле `package.json`;
- может определять дополнительные глобальные переменные.

Линтер Biome автоматически включит правила, принадлежащие домену, когда обнаружит определенные зависимости в ближайшем `package.json`. Например, если обнаружена зависимость `mocha`, Biome включит **рекомендованные правила** домена [`test`](/linter/domains#test).

Однако, если нет `package.json` или конфигурация по умолчанию не применяется, вы можете включить домен через конфигурацию:

```json title="biome.json" ins={4}
{
  "linter": {
    "domains": {
      "test": "recommended"
    }
  }
}
```

Дополнительно вы можете включить **все** правила, принадлежащие домену, используя значение `"all"`:


```json title="biome.json" ins={4} mark="all"
{
  "linter": {
    "domains": {
      "test": "all"
    }
  }
}
```

Как и правила и группы, вы также можете отключить правила, принадлежащие домену, используя значение `"off"`:

```json title="biome.json" ins={4} mark="off"
{
  "linter": {
    "domains": {
      "test": "off"
    }
  }
}
```

Чтобы узнать больше о каждом домене, обратитесь к [соответствующей странице](/linter/domains).

## Подавление правил линтера

Вы можете обратиться к [странице подавления](/analyzer/suppressions).

## Интеграция с редакторами

Первоклассная интеграция с редакторами, совместимыми с LSP, позволяет вам настраивать определенные аспекты того, как должен себя вести Biome.

Когда Biome обнаруживает нарушение, в редактор отправляется диагностика вместе с произвольным количеством code actions, которые предназначены для устранения диагностики.
Эти действия:
- возможное исправление кода. Это исправление кода появляется только в том случае, если правило **имеет** исправление кода. Исправление кода появляется независимо от того, безопасно оно или небезопасно.
- подавление диагностики [с помощью встроенного подавления](/analyzer/suppressions#inline-suppressions);
- подавление диагностики [с помощью подавления верхнего уровня](/analyzer/suppressions#top-level-suppressions).

Обычно, позиционируя курсор в диапазоне диагностики и нажимая определенную комбинацию клавиш (она варьируется в зависимости от редактора), появится всплывающая подсказка с возможными code actions.

По умолчанию эти действия всегда отображаются редактором, однако можно отказаться от них.

### Применение действий при сохранении

Используйте code action `source.fixAll.biome`, чтобы указать Biome применить все **безопасные исправления** при сохранении.

<EditorAction action="source.fixAll.biome" />


### Подавления в редакторе

Используйте `source.suppressRule.inline.biome`, чтобы контролировать, должен ли редактор показывать встроенное подавляющее code action:

<EditorAction action="source.suppressRule.inline.biome" off={true} />

Используйте `source.suppressRule.topLevel.biome`, чтобы контролировать, должен ли редактор показывать подавляющее code action верхнего уровня:

<EditorAction action="source.suppressRule.topLevel.biome" off={true} />



## Миграция с других линтеров

Многие правила линтера Biome вдохновлены другими линтерами.
Если вы хотите перейти с других линтеров, таких как ESLint или `typescript-eslint`, ознакомьтесь со [страницей источников правил](/linter/rules-sources).
Если вы переходите с ESLint, есть отдельное [руководство по миграции](/guides/migrate-eslint-prettier#migrate-from-eslint).

<Steps>

1. Используйте команду `biome migrate eslint`, чтобы перенести правила, определенные в вашем конфигурационном файле `eslint`, в `biome.json`:
    ```shell
    biome migrate eslint
    ```
2. Пролинтуйте проект, подавляя возможные новые правила, которые обнаружит Biome, используя следующую команду:
    ```shell
    biome lint --write --unsafe --suppress="suppressed due to migration"
    ```
   Команда подавит все нарушения линтинга, которые найдет Biome, используя причину `"suppressed due to migration"`. Теперь линтер не должен выдавать ошибок, и можно удалить комментарии подавления на более позднем этапе.
</Steps>


## Группы линтера

Линтер разделяет правила на _группы_. Группы предназначены для предоставления некоторой категории, к которой относятся правила. Эта информация становится полезной для пользователей при выборе правила для включения/отключения или для разработчиков при создании новых правил линтера.

### Accessibility

Правила, направленные на предотвращение проблем доступности.

### Complexity
Правила, сфокусированные на проверке сложного кода, который мог бы быть упрощен.

### Correctness
Правила, обнаруживающие код, который гарантированно является неправильным или бесполезным.

### Nursery
Новые правила, которые все еще находятся в разработке. Правила Nursery требуют явного включения через конфигурацию в стабильных версиях, потому что они все еще могут иметь баги или проблемы с производительностью. Они включены по умолчанию в ночных сборках, но поскольку они нестабильны, их серьезность диагностики может быть установлена на ошибку или предупреждение, в зависимости от того, намереваемся ли мы, чтобы правило было рекомендованным или нет, когда оно в конечном итоге стабилизируется. Правила Nursery переходят в другие группы, как только становятся стабильными, или могут быть удалены. Правила, принадлежащие этой группе, не подпадают под семантическое версионирование.

### Performance
Правила, отлавливающие способы, которыми ваш код может быть написан для более быстрого выполнения или в целом более эффективным.

### Security
Правила, обнаруживающие потенциальные уязвимости безопасности.

### Style
Правила, обеспечивающие последовательный и идиоматичный способ написания вашего кода. По умолчанию эти правила будут генерировать только предупреждения вместо ошибок.

### Suspicious
Правила, обнаруживающие код, который, вероятно, является неправильным или бесполезным.


## Часто задаваемые вопросы (FAQ)

### Почему правило X имеет *небезопасное* исправление? Оно кажется мне безопасным.

Существуют различные причины, по которым команда Biome решает пометить исправление как небезопасное, но в основном это сводится к следующему:
- правило линтера все еще находится в активной разработке, как и исправление;
- исправление правила может изменить семантику программы, поэтому исправление должно быть выбрано пользователем;
- исправление правила может ухудшить DX при вводе и/или сохранении. Примером является `noUnusedVariables`, которое добавляет `_` к имени неиспользуемых переменных. Это может ухудшить DX программистов при вводе и сохранении. Вы можете изменить это поведение через [конфигурацию](/linter/#configure-the-code-fix).

Если исправление кода не следует этим трем рекомендациям, возможно, команда забыла сделать исправление правила безопасным. Пожалуйста, откройте issue или отправьте PR!

### Почему линтер Biome такой медленный по сравнению с v1?

Начиная с Biome v2, мы расширили его архитектуру с помощью инструмента под названием Scanner. Scanner отвечает за обход файлов вашего проекта и создание важной информации, такой как граф модулей и выведенные типы.

Такая информация **необходима** для некоторых правил, таких как `noFloatingPromises`, `noUnresolvedImports` или `noImportCycles`, которые иначе не могут функционировать. Обычно для правил, принадлежащих [домену project](/linter/domains/#project)

Scanner является **опциональным** и запускается только при включении правила, принадлежащего [домену project](/linter/domains#project-rules).

На основе наших тестов мы заметили примерно следующие цифры:
|           | Без Scanner | С Scanner |
|-----------|-----------------|--------------|
| ~2k файлов | ~800ms          | ~2s          |
| ~5k файлов | ~1000ms         | ~8s          |

Также стоит упомянуть, что **мы знаем** об этом влиянии на производительность, и команда обязуется улучшить производительность в этой части программного обеспечения.

См. [руководство по исследованию медлительности](/guides/investigate-slowness) для советов по исследованию и смягчению замедлений.

Если вы заметите какие-то аномальные цифры в плане памяти или времени, пожалуйста, создайте issue со ссылкой на репозиторий, чтобы мы могли помочь.

### Почему Biome использует так много памяти?

Если вы используете расширение для редактора, которое использует Biome, вы можете заметить, что один из его процессов может использовать много памяти.

Обычно это происходит, если вы включаете одно из правил, принадлежащих [домену project](/linter/domains/#project).

Начиная с Biome v2, инструментарий теперь может использовать TypeScript для вывода типов и предоставления более мощных правил. Для достижения этого Biome сканирует файлы `.d.ts` внутри папки `node_modules`, включая файлы транзитивных зависимостей.

Хотя это может показаться глупой ошибкой, это намеренно из-за того, как работает язык. Библиотеки **могут экспортировать типы из своих зависимостей**, которые конечные пользователи могут не зависеть напрямую.

Например, вы можете зависеть от библиотеки `@org/foo`, которая экспортирует тип `Validator`, однако этот `Validator` приходит из библиотеки `@other-org/validator`, которая является *зависимостью `@org/foo`*. Однако библиотека `@other-org/validator` не является прямой зависимостью проекта.

**Команда знает** об этом ограничении и будет работать над оптимизацией инфраструктуры со временем и ресурсами.
