---
title: Конфигурация
description: Как настроить и сконфигурировать Biome с помощью biome.json.
---

{/** Make sure to update the redirect in `static/_redirects` when changing the configuration title --> **/}

## `$schema`

Позволяет указать путь к файлу JSON-схемы.

Мы публикуем файл JSON-схемы для наших файлов `biome.json`/`biome.jsonc`.

Вы можете указать относительный путь к схеме внутри NPM-пакета `@biomejs/biome`, если он установлен в папке `node_modules`:

```json title="biome.json"
{
  "$schema": "./node_modules/@biomejs/biome/configuration_schema.json"
}
```

Если у вас возникли проблемы с разрешением физического файла, вы можете использовать схему, опубликованную на этом сайте:

```json title="biome.json"
{
  "$schema": "https://biomejs.dev/schemas/2.0.5/schema.json"
}
```

## `extends`

Список путей к другим файлам конфигурации Biome. Biome разрешает и применяет настройки конфигурации из файлов, содержащихся в списке `extends`, и в конечном итоге применяет параметры, содержащиеся в этом файле `biome.json`/`biome.jsonc`.

Порядок путей расширения идет от наименее релевантного к наиболее релевантному.

Начиная с версии 2, эта опция принимает строку, которая должна соответствовать значению `"//"`, что может быть использовано при настройке [монорепозиториев](/ru/guides/big-projects#monorepo).

## `root`

Должна ли эта конфигурация рассматриваться как корневая. По умолчанию любой файл конфигурации считается корневым.
Когда файл конфигурации является "вложенной конфигурацией", он должен устанавливать `"root": false`, иначе будет выброшена ошибка.

Это необходимо для того, чтобы Biome мог одновременно обрабатывать несколько файлов в CLI и редакторах.

> По умолчанию: `true`


## `files`

### `files.includes`

Список [glob-шаблонов](#glob-syntax-reference) файлов для обработки.

Если папка соответствует glob-шаблону, будут обработаны все файлы внутри этой папки.

Следующий пример соответствует всем файлам с расширением `.js` внутри папки `src`:

```json title="biome.json"
{
  "files": {
    "includes": ["src/**/*.js"]
  }
}
```

`*` используется для соответствия _всем файлам в папке_, в то время как `**` _рекурсивно_ соответствует всем файлам и подпапкам в папке. Для получения дополнительной информации о glob-шаблонах см. [справочник по синтаксису glob](#glob-syntax-reference).

`includes` также поддерживает отрицательные шаблоны или исключения. Это шаблоны, которые начинаются с `!` и могут использоваться для указания Biome обрабатывать все файлы _кроме_ тех, которые соответствуют отрицательному шаблону. При использовании отрицательного шаблона вы всегда должны сначала указывать `**` для соответствия всем файлам и папкам, иначе отрицательный шаблон не будет соответствовать никаким файлам.

Обратите внимание, что исключения обрабатываются по порядку, что позволяет указывать исключения к исключениям.

Рассмотрим следующий пример:

```json title="biome.json"
{
  "files": {
    "includes": ["**", "!**/*.test.js", "**/special.test.js", "!test"]
  }
}
```

Этот пример указывает, что:

1. Обрабатываются все файлы внутри всех (под)папок благодаря шаблону `**`...
2. ... _кроме_ случаев, когда эти файлы имеют расширение `.test.js`...
3. ... но файл `special.test.ts` _все равно_ обрабатывается...
4. ... _кроме_ случаев, когда он находится в папке с именем `test`, потому что _никакие_ файлы внутри этой папки не обрабатываются.

:::note
Использование `!test` для полного исключения директории поддерживается только в `files.includes`. В других местах, где используется `includes` (`linter.includes`, `formatter.includes` и т.д.), вам нужно использовать `!/test/**` для исключения директории.
:::

Это означает, что:

* `src/app.js` **обрабатывается**.
* `src/app.test.js` **не обрабатывается**.
* `src/special.test.js` **обрабатывается**.
* `test/special.test.js` **не обрабатывается**.

Обратите внимание, что файлы внутри `node_modules/` игнорируются независимо от настройки `files.includes`.

#### Взаимодействие со сканером

Biome имеет [сканер](/ru/internals/architecture/#scanner), который отвечает за обнаружение вложенных файлов конфигурации, а также файлов `.gitignore`. Он также может индексировать исходные файлы, если одно или несколько правил из [домена проекта](/ru/linter/domains/#project) включены.

Сканер учитывает как `files.includes`, так и игнорируемые шаблоны из файлов `.gitignore`, но есть два исключения, о которых следует знать:
* Специальные файлы, такие как `biome.json` и `.gitignore`, имеют приоритет над любыми игнорируемыми шаблонами в `files.includes`.
* Если включено любое правило из домена проекта, сканер будет индексировать исходные файлы _включая их зависимости_. Это означает, что файлы, которые игнорируются как часть `files.includes`, все равно могут быть проиндексированы сканером, если есть другой включенный файл, который импортирует эти файлы. Это также означает, что файлы `.d.ts` и манифесты `package.json` внутри `node_modules/` также могут быть проиндексированы.

Если вы хотите явно заставить некоторые файлы игнорироваться сканером, вы можете сделать это, используя так называемый _шаблон принудительного игнорирования_. Шаблон принудительного игнорирования выглядит как обычный отрицательный шаблон, но начинается с двойного восклицательного знака (`!!`).

Например, вы можете указать Biome никогда не заглядывать внутрь какой-либо папки `dist/`, используя следующую конфигурацию:

```json title="biome.json"
{
  "files": {
    "includes": ["**", "!!**/dist"]
  }
}
```

Мы рекомендуем использовать синтаксис принудительного игнорирования для любых папок, содержащих _выходные_ файлы, таких как `build/` и `dist/`. Для таких папок крайне маловероятно, что индексация имеет какую-либо полезную пользу. Для папок, содержащих сгенерированные файлы, мы рекомендуем использовать обычные шаблоны игнорирования, чтобы информация о типах все еще могла быть извлечена из файлов.

Для вложенных файлов `biome.json`, а также файлов `.gitignore`, которые вы хотите явно игнорировать, также должен использоваться синтаксис принудительного игнорирования.

### `files.ignoreUnknown`

Если `true`, Biome не будет выдавать диагностику, если обнаружит файлы, которые не может обработать.

```json title="biome.json"
{
  "files": {
    "ignoreUnknown": true
  }
}
```

> По умолчанию: `false`

### `files.maxSize`

Максимально допустимый размер для файлов исходного кода в байтах. Файлы, превышающие этот лимит, будут игнорироваться из соображений производительности.

> По умолчанию: `1048576` (1024*1024, 1MB)

### `files.experimentalScannerIgnores`

:::caution
Эта опция была **устаревшей** и может быть удалена в будущем релизе.
Пожалуйста, используйте [_синтаксис принудительного игнорирования_](/ru/reference/configuration/#interaction-with-the-scanner) с `files.includes` вместо этого.
:::

Массив литеральных сегментов пути, которые сканер должен игнорировать во время обхода. Игнорируемые файлы не будут проиндексированы, что означает, что эти файлы не будут частью графа модулей, и типы не будут выведены из них.

## `vcs`

Набор свойств для интеграции Biome с VCS (системой контроля версий).

### `vcs.enabled`

Должен ли Biome интегрироваться с клиентом VCS.

> По умолчанию: `false`

### `vcs.clientKind`

Тип клиента.

Значения:
- `"git"`

### `vcs.useIgnoreFile`

Должен ли Biome использовать файлы игнорирования VCS проекта. Когда `true`, Biome будет игнорировать файлы, указанные в файлах игнорирования VCS, а также те, которые указаны в файлах `.ignore`.

Эта функция также поддерживает вложенные файлы игнорирования.

Корневой файл игнорирования имеет ту же семантику, что и корневой [`files.includes`](/ru/reference/configuration#filesincludes).

### `vcs.root`

Папка, где Biome должен проверять наличие файлов VCS. По умолчанию Biome будет использовать ту же папку, где был найден `biome.json`.

Если Biome не может найти конфигурацию, он попытается использовать текущий рабочий каталог.
Если текущий рабочий каталог не может быть найден, Biome не будет использовать интеграцию VCS, и будет выдана диагностика.

### `vcs.defaultBranch`

Основная ветка проекта. Biome будет использовать эту ветку при оценке измененных файлов.

## `linter`

### `linter.enabled`

Включает линтер Biome.

> По умолчанию: `true`

### `linter.includes`

Список [glob-шаблонов](#glob-syntax-reference) файлов для линтинга.

Следующий пример выполняет линтинг всех файлов с расширением `.js` внутри папки `src`:

```json title="biome.json"
{
  "linter": {
    "includes": ["src/**/*.js"]
  }
}
```

`*` используется для соответствия _всем файлам в папке_, в то время как `**` _рекурсивно_ соответствует всем файлам и подпапкам в папке. Для получения дополнительной информации о glob-шаблонах см. [справочник по синтаксису glob](#glob-syntax-reference).

`includes` также поддерживает отрицательные шаблоны или исключения. Это шаблоны, которые начинаются с `!` и могут использоваться для указания Biome обрабатывать все файлы _кроме_ тех, которые соответствуют отрицательному шаблону.

Обратите внимание, что исключения обрабатываются по порядку, что позволяет указывать исключения к исключениям.

Рассмотрим следующий пример:

```json title="biome.json"
{
  "linter": {
    "includes": ["**", "!**/*.test.js", "**/special.test.js"]
  }
}
```

Этот пример указывает, что:

1. Все файлы внутри всех (под)папок проходят линтинг благодаря шаблону `**`...
2. ... _кроме_ случаев, когда эти файлы имеют расширение `.test.js`...
3. ... но файл `special.test.ts` _все равно_ проходит линтинг.

Это означает, что:

* `src/app.js` **проходит линтинг**.
* `src/app.test.js` **не проходит линтинг**.
* `src/special.test.js` **проходит линтинг**.

Обратите внимание, что `linter.includes` применяется *после* `files.includes`. Это означает, что любой файл, который не соответствует `files.includes`, больше не может соответствовать `linter.includes`. Это означает, что следующий пример **не работает**:

```json5 title="biome.jsonc"
{
  "files": {
    "includes": "src/**"
  },
  "linter": {
    // Это не соответствует ничему, потому что нет пересечения с `files.includes`:
    "includes": "scripts/**"
  }
}
```

Если `linter.includes` не указан, все файлы, соответствующие [`files.includes`](#filesincludes), проходят линтинг.

:::note
Из-за технического ограничения `linter.includes` также не может соответствовать папкам, в то время как `files.includes` может. Если вы хотите соответствовать всем файлам внутри папки, вы должны явно добавить `/**` в конце.
:::

### `linter.rules.recommended`

Включает рекомендуемые правила для всех групп.

> По умолчанию: `true`


### `linter.rules.[group]`

Параметры, влияющие на правила одной группы. Biome поддерживает следующие группы:

- accessibility: правила, направленные на предотвращение проблем с доступностью.
- complexity: правила, которые фокусируются на проверке сложного кода, который можно упростить.
- correctness: правила, которые обнаруживают код, который гарантированно неверен или бесполезен.
- nursery: новые правила, которые все еще находятся в разработке. Правила nursery требуют явного включения через конфигурацию в стабильных версиях, потому что у них все еще могут быть ошибки или проблемы с производительностью. Они включены по умолчанию в ночных сборках, но, поскольку они нестабильны, серьезность их диагностики может быть установлена как ошибка или предупреждение, в зависимости от того, планируем ли мы, чтобы правило было рекомендованным или нет, когда оно в конечном итоге стабилизируется. Правила nursery переходят в другие группы, когда становятся стабильными, или могут быть удалены. Правила, принадлежащие этой группе, не подлежат семантическому версионированию.
- performance: правила, обнаруживающие способы, как ваш код может быть написан для более быстрой работы или в целом более эффективным.
- security: правила, которые обнаруживают потенциальные уязвимости безопасности.
- style: правила, обеспечивающие последовательный и идиоматический способ написания вашего кода.
- suspicious: правила, которые обнаруживают код, который, вероятно, неверен или бесполезен.

Каждая группа может принимать в качестве значения строку, представляющую серьезность, или объект, где каждое правило может быть настроено.

При передаче серьезности вы можете контролировать серьезность, выдаваемую всеми правилами, принадлежащими группе.
Например, вы можете настроить группу `a11y` для выдачи информационной диагностики:

```json title="biome.json"
{
  "linter": {
    "rules": {
      "a11y": "info"
    }
  }
}
```

Вот допустимые значения:
- `"on"`: каждое правило, принадлежащее группе, будет выдавать диагностику с серьезностью по умолчанию для этого правила. Обратитесь к документации правила или используйте команду `explain`:
    ```shell showLineNumbers=false
    biome explain noDebugger
    ```
- `"off"`: ни одно из правил, принадлежащих группе, не будет выдавать никакой диагностики.
- `"info"`: все правила, принадлежащие группе, будут выдавать [диагностику с информационной серьезностью](/ru/reference/diagnostics#information).
- `"warn"`: все правила, принадлежащие группе, будут выдавать [диагностику с серьезностью предупреждения](/ru/reference/diagnostics#warning).
- `"error"`: все правила, принадлежащие группе, будут выдавать [диагностику с серьезностью ошибки](/ru/reference/diagnostics#error).


### `linter.rules.[group].recommended`

Включает рекомендуемые правила для одной группы.

Пример:

```json title="biome.json"
{
  "linter": {
    "enabled": true,
    "rules": {
      "nursery": {
        "recommended": true
      }
    }
  }
}
```

## `assist`

### `assist.enabled`

Включает помощника Biome.

> По умолчанию: `true`


### `assist.includes`

Список [glob-шаблонов](#glob-syntax-reference) файлов для линтинга.

Следующий пример анализирует все файлы с расширением `.js` внутри папки `src`:

```json title="biome.json"
{
  "assist": {
    "includes": ["src/**/*.js"]
  }
}
```

`*` используется для соответствия _всем файлам в папке_, в то время как `**` _рекурсивно_ соответствует всем файлам и подпапкам в папке. Для получения дополнительной информации о glob-шаблонах см. [справочник по синтаксису glob](#glob-syntax-reference).

`includes` также поддерживает отрицательные шаблоны или исключения. Это шаблоны, которые начинаются с `!` и могут использоваться для указания Biome обрабатывать все файлы _кроме_ тех, которые соответствуют отрицательному шаблону.

Обратите внимание, что исключения обрабатываются по порядку, что позволяет указывать исключения к исключениям.

Рассмотрим следующий пример:

```json title="biome.json"
{
  "assist": {
    "includes": ["**", "!**/*.test.js", "**/special.test.js"]
  }
}
```

Этот пример указывает, что:

1. Все файлы внутри всех (под)папок анализируются благодаря шаблону `**`...
2. ... _кроме_ случаев, когда эти файлы имеют расширение `.test.js`...
3. ... но файл `special.test.ts` _все равно_ анализируется.

Это означает, что:

* `src/app.js` **анализируется**.
* `src/app.test.js` **не анализируется**.
* `src/special.test.js` **анализируется**.

Обратите внимание, что `assist.includes` применяется *после* `files.includes`. Это означает, что любой файл, который не соответствует `files.includes`, больше не может соответствовать `assist.includes`. Это означает, что следующий пример **не работает**:

```json5 title="biome.jsonc"
{
  "files": {
    "includes": "src/**"
  },
  "assist": {
    // Это не соответствует ничему, потому что нет пересечения с `files.includes`:
    "includes": "scripts/**"
  }
}
```

Если `assist.includes` не указан, все файлы, соответствующие [`files.includes`](#filesincludes), проходят линтинг.

:::note
Из-за технического ограничения `assist.includes` также не может соответствовать папкам, в то время как `files.includes` может. Если вы хотите соответствовать всем файлам внутри папки, вы должны явно добавить `/**` в конце.
:::

### `assist.actions.recommended`

Включает рекомендуемые действия для всех групп.

### `assist.actions.[group]`

Параметры, влияющие на правила одной группы. Biome поддерживает следующие группы:

- source: эта группа представляет те действия, которые могут быть безопасно применены к документу при сохранении. Все эти действия в целом безопасны, они обычно не изменяют функциональность программы.

### `assist.actions.[group].recommended`

Включает рекомендуемые правила для одной группы.

Пример:

```json title="biome.json"
{
  "assist": {
    "enabled": true,
    "actions": {
      "source": {
        "recommended": true
      }
    }
  }
}
```

## `formatter`

Эти параметры применяются ко всем языкам. Ниже приведены дополнительные параметры форматирования для конкретных языков.

### `formatter.enabled`

Включает форматировщик Biome.

> По умолчанию: `true`

### `formatter.includes`

Список [glob-шаблонов](#glob-syntax-reference) файлов для форматирования.

Следующий пример форматирует все файлы с расширением `.js` внутри папки `src`:

```json title="biome.json"
{
  "formatter": {
    "includes": ["src/**/*.js"]
  }
}
```

`*` используется для соответствия _всем файлам в папке_, в то время как `**` _рекурсивно_ соответствует всем файлам и подпапкам в папке. Для получения дополнительной информации о glob-шаблонах см. [справочник по синтаксису glob](#glob-syntax-reference).

`includes` также поддерживает отрицательные шаблоны или исключения. Это шаблоны, которые начинаются с `!` и могут использоваться для указания Biome обрабатывать все файлы _кроме_ тех, которые соответствуют отрицательному шаблону.

Обратите внимание, что исключения обрабатываются по порядку, что позволяет указывать исключения к исключениям.

Рассмотрим следующий пример:

```json title="biome.json"
{
  "formatter": {
    "includes": ["**", "!**/*.test.js", "**/special.test.js"]
  }
}
```

Этот пример указывает, что:

1. Все файлы внутри всех (под)папок форматируются благодаря шаблону `**`...
2. ... _кроме_ случаев, когда эти файлы имеют расширение `.test.js`...
3. ... но файл `special.test.ts` _все равно_ форматируется.

Это означает, что:

* `src/app.js` **форматируется**.
* `src/app.test.js` **не форматируется**.
* `src/special.test.js` **форматируется**.

Обратите внимание, что `formatter.includes` применяется *после* `files.includes`. Это означает, что любой файл, который не соответствует `files.includes`, больше не может соответствовать `formatter.includes`. Это означает, что следующий пример **не работает**:

```json5 title="biome.jsonc"
{
  "files": {
    "includes": "src/**"
  },
  "formatter": {
    // Это не соответствует ничему, потому что нет пересечения с `files.includes`:
    "includes": "scripts/**"
  }
}
```

Если `formatter.includes` не указан, все файлы, соответствующие [`files.includes`](#filesincludes), форматируются.

:::note
Из-за технического ограничения `formatter.includes` также не может соответствовать папкам, в то время как `files.includes` может. Если вы хотите соответствовать всем файлам внутри папки, вы должны явно добавить `/**` в конце.
:::

### `formatter.formatWithErrors`

Разрешает форматирование документа, содержащего синтаксические ошибки.



```json title="biome.json"
{
  "formatter": {
    "formatWithErrors": true
  }
}
```

> По умолчанию: `false`

### `formatter.indentStyle`

Стиль отступа. Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `formatter.indentWidth`

Насколько большим должен быть отступ.

> По умолчанию: `2`

### `formatter.lineEnding`

Тип окончания строки.
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `formatter.lineWidth`

Количество символов, которое может быть записано в одной строке.

> По умолчанию: `80`

### `formatter.attributePosition`

Стиль позиции атрибутов в HTMLish-языках.
- `"auto"`, атрибуты автоматически форматируются и будут переноситься на несколько строк только при достижении определенных критериев;
- `"multiline"`, атрибуты будут переноситься на несколько строк, если используется более 1 атрибута.

> По умолчанию: `"auto"`

### `formatter.bracketSpacing`

Следует ли добавлять пробелы между скобками и внутренними значениями.

> По умолчанию: `true`

### `formatter.expand`

Следует ли разворачивать массивы и объекты на несколько строк.
- `"auto"`, объектные литералы форматируются на несколько строк, если первое свойство имеет перевод строки, а массивы форматируются на одну строку, если помещаются в строке.
- `"always"`, эти литералы форматируются на несколько строк независимо от длины списка.
- `"never"`, эти литералы форматируются на одну строку, если помещаются в строке.

При форматировании `package.json` Biome будет использовать `always`, если не настроено иное.

> По умолчанию: `"auto"`

### `formatter.useEditorconfig`

Должен ли Biome использовать файл `.editorconfig` для определения параметров форматирования.

Файлы конфигурации `.editorconfig` и `biome.json` будут следовать следующим правилам:

- Настройки форматирования в `biome.json` всегда имеют приоритет над файлами `.editorconfig`.
- Файлы `.editorconfig`, которые существуют выше в иерархии, чем файл `biome.json`, уже игнорируются. Это сделано для того, чтобы избежать загрузки настроек форматирования из домашнего каталога кого-либо в проект с файлом `biome.json`.
- Вложенные файлы `.editorconfig` в настоящее время не поддерживаются.

> По умолчанию: `false`


## `javascript`

Эти параметры применяются только к файлам JavaScript (и TypeScript).

### `javascript.parser.unsafeParameterDecoratorsEnabled`

Разрешает поддержку небезопасных/экспериментальных декораторов параметров.

```json title="biome.json"
{
  "javascript": {
    "parser": {
	    "unsafeParameterDecoratorsEnabled": true
    }
  }
}
```

> По умолчанию: `false`


### `javascript.parser.jsxEverywhere`

Когда установлено в `true`, разрешает разбор JSX-синтаксиса внутри файлов `.js`. Когда установлено в `false`, Biome будет выдавать диагностику при обнаружении JSX-синтаксиса внутри файлов `.js`.

> По умолчанию: `true`

```json title="biome.json"
{
  "javascript": {
    "parser": {
      "jsxEverywhere": false
    }
  }
}
```

### `javascript.formatter.quoteStyle`

Тип кавычек, используемых при представлении строковых литералов. Может быть `"single"` или `"double"`.

> По умолчанию: `"double"`

```json title="biome.json"
{
  "javascript": {
    "formatter": {
      "quoteStyle": "single"
    }
  }
}
```

### `javascript.formatter.jsxQuoteStyle`

Тип кавычек, используемых при представлении jsx строковых литералов. Может быть `"single"` или `"double"`.

> По умолчанию: `"double"`

```json title="biome.json"
{
  "javascript": {
    "formatter": {
      "jsxQuoteStyle": "single"
    }
  }
}
```

### `javascript.formatter.quoteProperties`

Когда свойства внутри объектов должны быть заключены в кавычки. Может быть `"asNeeded"` или `"preserve"`.

> По умолчанию: `"asNeeded"`

```json title="biome.json"
{
  "javascript": {
    "formatter": {
      "quoteProperties": "preserve"
    }
  }
}
```

### `javascript.formatter.trailingCommas`

Печатать завершающие запятые везде, где это возможно, в многострочных синтаксических структурах, разделенных запятыми. Возможные значения:
- `"all"`, завершающая запятая всегда добавляется;
- `"es5"`, завершающая запятая добавляется только в местах, где она поддерживается старыми версиями JavaScript;
- `"none"`, завершающие запятые никогда не добавляются.

> По умолчанию: `"all"`

### `javascript.formatter.semicolons`

Настраивает, где форматировщик печатает точки с запятой:
- `"always"`, точка с запятой всегда добавляется в конце каждого оператора;
- `"asNeeded"`, точки с запятой добавляются только в местах, где это необходимо, для защиты от [ASI](https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion).

> По умолчанию: `"always"`

Пример:


```json title="biome.json"
{
  "javascript": {
    "formatter": {
      "semicolons": "asNeeded"
    }
  }
}
```

### `javascript.formatter.arrowParentheses`

Следует ли добавлять необязательные скобки к стрелочным функциям:
- `"always"`, скобки всегда добавляются;
- `"asNeeded"`, скобки добавляются только когда они нужны.

> По умолчанию: `"always"`

### `javascript.formatter.enabled`

Включает форматировщик Biome для файлов JavaScript (и его супер-языков).

> По умолчанию: `true`

### `javascript.formatter.indentStyle`

Стиль отступа для файлов JavaScript (и его супер-языков). Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `javascript.formatter.indentWidth`

Насколько большим должен быть отступ для файлов JavaScript (и его супер-языков).

> По умолчанию: `2`

### `javascript.formatter.lineEnding`

Тип окончания строки для файлов JavaScript (и его супер-языков).
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `javascript.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах JavaScript (и его супер-языков).

> По умолчанию: `80`

### `javascript.formatter.bracketSameLine`

Следует ли размещать закрывающий `>` многострочного JSX-элемента на последней строке атрибутов или нет.

> По умолчанию: `false`

### `javascript.formatter.bracketSpacing`

Следует ли добавлять пробелы между скобками и внутренними значениями.

> По умолчанию: `true`

### `javascript.formatter.attributePosition`

Стиль позиции атрибутов в jsx-элементах.
- `"auto"`, не принудительно размещать один атрибут на строку.
- `"multiline"`, принудительно размещать один атрибут на строку.

> По умолчанию: `"auto"`

### `javascript.formatter.expand`

Следует ли разворачивать массивы и объекты на несколько строк.
- `"auto"`, объектные литералы форматируются на несколько строк, если первое свойство имеет перевод строки, а массивы форматируются на одну строку, если помещаются в строке.
- `"always"`, эти литералы форматируются на несколько строк независимо от длины списка.
- `"never"`, эти литералы форматируются на одну строку, если помещаются в строке.

> По умолчанию: `"auto"`


### `javascript.formatter.operatorLinebreak`

При разбиении бинарных выражений на несколько строк, разбивать их до или после бинарного оператора.

> По умолчанию: `"after"`.

- `"after`: оператор размещается после выражения:
  ```js title="file.js"
  if (
    expressionOne &&
    expressionTwo &&
    expressionThree &&
    expressionFour
  ) {}
  ```
- `"before`: оператор размещается перед выражением:
  ```js title="file.js"
  if (
    expressionOne
    && expressionTwo
    && expressionThree
    && expressionFour
  ) {}
  ```

### `javascript.globals`

Список глобальных имен, которые Biome должен игнорировать (анализатор, линтер и т.д.)

```json title="biome.json"
{
  "javascript": {
    "globals": ["$", "_", "externalVariable"]
  }
}
```

### `javascript.jsxRuntime`

Указывает тип runtime или трансформации, используемой для интерпретации JSX.

- `"transparent"` &mdash; указывает на современную или нативную JSX-среду, которая не требует специальной обработки Biome.
- `"reactClassic"` &mdash; указывает на классическую React-среду, которая требует импорта `React`. Соответствует значению `react` для опции `jsx` в [`tsconfig.json`](https://www.typescriptlang.org/tsconfig#jsx) TypeScript.

```json title="biome.json"
{
  "javascript": {
    "jsxRuntime": "reactClassic"
  }
}
```

Для получения дополнительной информации о старом и новом JSX runtime см.:
https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html

> По умолчанию: `"transparent"`

### `javascript.linter.enabled`

Включает линтер Biome для файлов JavaScript (и его супер-языков).

> По умолчанию: `true`


```json title="biome.json"
{
  "javascript": {
    "linter": {
      "enabled": false
    }
  }
}
```


### `javascript.assist.enabled`

Включает помощника Biome для файлов JavaScript (и его супер-языков).

> По умолчанию: `true`

```json title="biome.json"
{
  "javascript": {
    "assist": {
      "enabled": false
    }
  }
}
```

## `json`

Параметры, применяемые к файлам JSON.

### `json.parser.allowComments`

Включает разбор комментариев в файлах JSON.



```json title="biome.json"
{
  "json": {
    "parser": {
      "allowComments": true
    }
  }
}
```

### `json.parser.allowTrailingCommas`

Включает разбор завершающих запятых в файлах JSON.



```json title="biome.json"
{
  "json": {
    "parser": {
      "allowTrailingCommas": true
    }
  }
}
```

### `json.formatter.enabled`

Включает форматировщик Biome для файлов JSON (и его супер-языков).

> По умолчанию: `true`

```json title="biome.json"
{
  "json": {
    "formatter": {
      "enabled": false
    }
  }
}
```

### `json.formatter.indentStyle`


Стиль отступа для файлов JSON (и его супер-языков). Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `json.formatter.indentWidth`

Насколько большим должен быть отступ для файлов JSON (и его супер-языков).

> По умолчанию: `2`

### `json.formatter.lineEnding`

Тип окончания строки для файлов JSON (и его супер-языков).
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `json.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах JSON (и его супер-языков).

> По умолчанию: `80`

### `json.formatter.trailingCommas`

Печатать завершающие запятые везде, где это возможно, в многострочных синтаксических структурах, разделенных запятыми.

Допустимые значения:
- `"none"`: завершающая запятая удаляется;
- `"all"`: завершающая запятая сохраняется **и** предпочитается.

> По умолчанию: `"none"`

### `json.formatter.bracketSpacing`

Следует ли добавлять пробелы между скобками и внутренними значениями.

> По умолчанию: `true`

### `json.formatter.expand`

Следует ли разворачивать массивы и объекты на несколько строк.
- `"auto"`, объектные литералы форматируются на несколько строк, если первое свойство имеет перевод строки, а массивы форматируются на одну строку, если помещаются в строке.
- `"always"`, эти литералы форматируются на несколько строк независимо от длины списка.
- `"never"`, эти литералы форматируются на одну строку, если помещаются в строке.

При форматировании `package.json` Biome будет использовать `always`, если не настроено иное.

> По умолчанию: `"auto"`

### `json.linter.enabled`

Включает форматировщик Biome для файлов JSON (и его супер-языков).

> По умолчанию: `true`

```json title="biome.json"
{
  "json": {
    "linter": {
      "enabled": false
    }
  }
}
```


### `json.assist.enabled`

Включает помощника Biome для файлов JSON (и его супер-языков).

> По умолчанию: `true`

```json title="biome.json"
{
  "json": {
    "assist": {
      "enabled": false
    }
  }
}
```

## `css`

Параметры, применяемые к файлам CSS.

### `css.parser.cssModules`

Включает разбор [CSS-модулей](https://github.com/css-modules/css-modules).

> По умолчанию: `false`

### `css.parser.tailwindDirectives`

<div style="display: none">tailwindDirectives, tailwind, tailwind directives, tailwind syntax</div>

Включает разбор специфичного синтаксиса [Tailwind](https://tailwindcss.com), такого как `@theme`, `@utility` и `@apply`.

> По умолчанию: `false`

### `css.formatter.enabled`

Включает форматировщик Biome для файлов CSS.

> По умолчанию: `false`

```json title="biome.json"
{
  "css": {
    "formatter": {
      "enabled": false
    }
  }
}
```

### `css.formatter.indentStyle`


Стиль отступа для файлов CSS. Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `css.formatter.indentWidth`

Насколько большим должен быть отступ для файлов CSS.

> По умолчанию: `2`


```json title="biome.json"
{
  "css": {
    "formatter": {
      "indentWidth": 2
    }
  }
}
```

### `css.formatter.lineEnding`

Тип окончания строки для файлов CSS.
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`



### `css.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах CSS.

> По умолчанию: `80`

### `css.formatter.quoteStyle`

Тип кавычек, используемых при представлении строковых литералов. Может быть `"single"` или `"double"`.

> По умолчанию: `"double"`

### `css.linter.enabled`

Включает линтер Biome для файлов CSS.

> По умолчанию: `true`

```json title="biome.json"
{
  "css": {
    "linter": {
      "enabled": false
    }
  }
}
```

### `css.assist.enabled`

Включает помощника Biome для файлов CSS.

> По умолчанию: `true`

```json title="biome.json"
{
  "css": {
    "assist": {
      "enabled": false
    }
  }
}
```

## `graphql`

Параметры, применяемые к файлам GraphQL.


### `graphql.formatter.enabled`

Включает форматировщик Biome для файлов GraphQL.

> По умолчанию: `false`

### `graphql.formatter.indentStyle`


Стиль отступа для файлов GraphQL. Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `graphql.formatter.indentWidth`

Насколько большим должен быть отступ для файлов GraphQL.

> По умолчанию: `2`

### `graphql.formatter.lineEnding`

Тип окончания строки для файлов GraphQL.
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `graphql.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах GraphQL.

> По умолчанию: `80`

### `graphql.formatter.quoteStyle`

Тип кавычек, используемых при представлении строковых литералов. Может быть `"single"` или `"double"`.

> По умолчанию: `"double"`

### `graphql.linter.enabled`

Включает линтер Biome для файлов GraphQL.

> По умолчанию: `true`

### `graphql.assist.enabled`

Включает помощника Biome для файлов GraphQL.

> По умолчанию: `true`



## `grit`

Параметры, применяемые к файлам Grit.


### `grit.formatter.enabled`

Включает форматировщик Biome для файлов Grit.

> По умолчанию: `false`

### `grit.formatter.indentStyle`


Стиль отступа для файлов Grit. Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`


### `grit.formatter.indentWidth`

Насколько большим должен быть отступ для файлов Grit.

> По умолчанию: `2`

### `grit.formatter.lineEnding`

Тип окончания строки для файлов Grit.
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `grit.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах Grit.

> По умолчанию: `80`

### `grit.formatter.quoteStyle`

Тип кавычек, используемых при представлении строковых литералов. Может быть `"single"` или `"double"`.

> По умолчанию: `"double"`

### `grit.linter.enabled`

Включает линтер Biome для файлов Grit.

> По умолчанию: `true`

```json title="biome.json"
{
  "grit": {
    "linter": {
      "enabled": false
    }
  }
}
```

### `grit.assist.enabled`

Включает помощника Biome для файлов Grit.

> По умолчанию: `true`

```json title="biome.json"
{
  "grit": {
    "assist": {
      "enabled": false
    }
  }
}
```

## `html`

:::caution
Хотя парсер, форматировщик и линтер HTML включены по умолчанию, они все еще считаются экспериментальными.
Критические изменения будут сведены к минимуму, однако введение исправлений и функций может изменить поведение инструментов.
:::

### `html.parser.interpolation`

Включает разбор двойных текстовых выражений, таких как `{{ expression }}`, внутри файлов `.html`.

> По умолчанию: `false`

### `html.formatter.enabled`

Включает форматировщик Biome для файлов HTML.

> По умолчанию: `false`

### `html.formatter.indentStyle`

Стиль отступа для файлов HTML. Может быть `"tab"` или `"space"`.

> По умолчанию: `"tab"`

### `html.formatter.indentWidth`

Насколько большим должен быть отступ для файлов HTML.

> По умолчанию: `2`

### `html.formatter.lineEnding`

Тип окончания строки для файлов HTML.
- `"lf"`, только перевод строки (`\n`), распространенный на Linux и macOS, а также внутри git-репозиториев;
- `"crlf"`, символы возврата каретки + перевода строки (`\r\n`), распространенные на Windows;
- `"cr"`, только символ возврата каретки (`\r`), используется очень редко.

> По умолчанию: `"lf"`

### `html.formatter.lineWidth`

Количество символов, которое может быть записано в одной строке в файлах HTML.

> По умолчанию: `80`

### `html.formatter.attributePosition`

Стиль позиции атрибутов в HTML-элементах.
- `"auto"`, атрибуты автоматически форматируются и будут переноситься на несколько строк только при достижении определенных критериев;
- `"multiline"`, атрибуты будут переноситься на несколько строк, если используется более 1 атрибута.

> По умолчанию: `"auto"`

### `html.formatter.bracketSameLine`

Следует ли прижимать закрывающую скобку многострочных HTML-тегов к концу последней строки, а не размещать ее отдельно на следующей строке.

> По умолчанию: `false`

### `html.formatter.whitespaceSensitivity`

<div style="display: none">whitespaceSensitivity, whitespace sensitivity</div>

Следует ли учитывать чувствительность к пробелам при форматировании HTML (и его супер-языков).

> По умолчанию: "css"


- `"css"`: форматировщик считает пробелы значимыми для элементов, которые имеют стиль отображения "inline" по умолчанию в таблицах стилей пользовательского агента браузера.
- `"strict"`: начальные и завершающие пробелы в содержимом считаются значимыми для всех элементов.

  Форматировщик должен оставить хотя бы один пробельный символ, если пробел присутствует.
  В противном случае, если пробела нет, он не должен добавлять его после `>` или перед `<`. Другими словами, если пробела нет, текстовое содержимое должно прилегать к тегам.

  Пример текста, прилегающего к тегам:
  ```html
  <b
     >content</b
  >
  ```
- `"ignore"`: пробелы считаются незначимыми. Форматировщик свободен удалять или добавлять пробелы по своему усмотрению.

### `html.formatter.indentScriptAndStyle`

<div style="display: none">indentScriptAndStyle, indent script, indent style</div>

*С версии 2.3: влияет только на файлы `.vue` и `.svelte`*

Следует ли делать отступы для содержимого тегов `<script>` и `<style>` для файлов Vue и Svelte. В настоящее время это не применяется к обычным HTML-файлам.

> По умолчанию: `false`

Когда true, содержимое тегов `<script>` и `<style>` будет иметь отступ на один уровень относительно тегов.

```vue title="foo.vue" del={2} ins={3}
<script>
import Bar from "./Bar.vue";
  import Bar from "./Bar.vue";
</script>
```

### `html.formatter.selfCloseVoidElements`

<div style="display: none">selfCloseVoidElements, void elements, self closing elements</div>

Должны ли пустые элементы быть самозакрывающимися. По умолчанию никогда.

> По умолчанию: `"never"`

- `"never"`: слэш `/` внутри пустых элементов удаляется форматировщиком.
- `"always"`: слэш `/` внутри пустых элементов всегда добавляется.

### `html.linter.enabled`

Включает линтер Biome для файлов HTML.

> По умолчанию: `true`

### `html.linter.assist`

Включает помощника Biome для файлов HTML.

> По умолчанию: `true`


## `overrides`

Список шаблонов.

Используйте эту конфигурацию для изменения поведения инструментов для определенных файлов.

Когда файл соответствует шаблону переопределения, конфигурация, указанная в этом шаблоне, будет переопределять конфигурацию верхнего уровня.

Порядок шаблонов имеет значение. Если файл *может* соответствовать трем шаблонам, используется только первый.

### `overrides.<ITEM>.includes`

Список [glob-шаблонов](https://en.wikipedia.org/wiki/Glob_(programming)) файлов, для которых следует применять настроенные параметры.

```jsonc title="biome.jsonc"
{
  "overrides": [{
    "includes": ["scripts/*.js"],
    // settings that should only apply to the files specified in the includes field.
  }]
}
```

### `overrides.<ITEM>.formatter`

Включает параметры конфигурации [форматировщика верхнего уровня](#formatter), за исключением `ignore` и `include`.

#### Примеры

Например, можно изменить `lineWidth`, `indentStyle` форматировщика для определенных файлов, которые включены в glob-путь `generated/**`:

```json title="biome.json"
{
  "formatter": {
    "lineWidth": 100
  },
  "overrides": [
    {
      "includes": ["generated/**"],
      "formatter": {
        "lineWidth": 160,
        "indentStyle": "space"
      }
    }
  ]
}
```

### `overrides.<ITEM>.linter`

Включает параметры конфигурации [линтера верхнего уровня](#linter), за исключением `ignore` и `include`.


#### Примеры

Вы можете отключить определенные правила для определенных glob-путей и отключить линтер для других glob-путей:

```json title="biome.json"
{
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "overrides": [
    {
      "includes": ["lib/**"],
      "linter": {
        "rules": {
          "suspicious": {
            "noDebugger": "off"
          }
        }
      }
    },
    {
      "includes": ["shims/**"],
      "linter": {
        "enabled": false
      }
    }
  ]
}
```

### `overrides.<ITEM>.javascript`

Включает параметры конфигурации [javascript верхнего уровня](#javascript). Позволяет переопределять настройки JavaScript для определенных файлов.

#### Примеры

Вы можете изменить поведение форматирования файлов JavaScript в определенных папках:

```json title="biome.json"
{
  "formatter": {
    "lineWidth": 120
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "single"
    }
  },
  "overrides": [
    {
      "includes": ["lib/**"],
      "javascript": {
        "formatter": {
          "quoteStyle": "double"
        }
      }
    }
  ]
}
```


### `overrides.<ITEM>.json`

Включает параметры конфигурации [json верхнего уровня](#json). Позволяет переопределять настройки JSON для определенных файлов.


#### Примеры

Вы можете включить функции разбора для определенных JSON-файлов:

```json title="biome.json"
{
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "overrides": [
    {
      "includes": [".vscode/**"],
      "json": {
        "parser": {
          "allowComments": true,
          "allowTrailingCommas": true
        }
      }
    }
  ]
}
```

### `overrides.<ITEM>.[language]`

Включает параметры конфигурации языка верхнего уровня. Позволяет переопределять настройки для конкретного языка для определенных файлов.

## Справочник по синтаксису glob

Glob-шаблоны используются для соответствия путям файлов и папок. Biome поддерживает следующий синтаксис в glob-шаблонах:

- `*` соответствует нулю или более символам. Не может соответствовать разделителю пути `/`.
- `**` рекурсивно соответствует директориям и файлам. Эта последовательность должна использоваться как целый компонент пути, поэтому `**a` и `b**` недопустимы и приведут к ошибке. Последовательность из более чем двух последовательных символов `*` также недопустима.
- `[...]` соответствует любому символу внутри скобок.
  Диапазоны символов также могут быть указаны, упорядоченные по Unicode, поэтому, например, `[0-9]` указывает любой символ между 0 и 9 включительно.
- `[!...]` является отрицанием `[...]`, т.е. соответствует любым символам **не** в скобках.
- Если весь glob начинается с `!`, это так называемый отрицательный шаблон. Этот glob соответствует только если путь _не_ соответствует glob. Отрицательные шаблоны не могут использоваться отдельно, они могут использоваться только как _исключение_ к обычному glob.
- При определении того, включен файл или нет, Biome также рассматривает родительские папки. Это означает, что если вы хотите _включить_ все файлы в папке, вам нужно использовать суффикс `/**` для соответствия этим файлам. Но если вы хотите _игнорировать_ все файлы в папке, вы можете сделать это без суффикса `/**`. Мы рекомендуем игнорировать папки без завершающего `/**`, чтобы избежать ненужного обхода, а также избежать риска загрузки Biome файла `biome.json` или файла `.gitignore` из игнорируемой папки.

Некоторые примеры:

- `dist/**` соответствует папке `dist/` и всем файлам внутри нее.
- `!dist` игнорирует папку `dist/` и все файлы внутри нее.
- `**/test/**` соответствует всем файлам под любой папкой с именем `test`, независимо от того, где они находятся. Например, `dist/test`, `src/test`.
- `**/*.js` соответствует всем файлам с расширением `.js` во всех папках.

:::caution
Glob-шаблоны могут использоваться в файле конфигурации Biome, но они также могут быть указаны из командной строки. Когда вы указываете glob в командной строке, он интерпретируется вашей оболочкой, а не Biome. Оболочки могут поддерживать слегка отличающийся синтаксис для glob-шаблонов. Например, некоторые оболочки не поддерживают рекурсивный шаблон `**`.
:::
